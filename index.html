<!DOCTYPE html>
<html xmlns='http://www.w3.org/1999/xhtml'>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>
      Device Capabilities API
    </title>
    <script src='https://www.w3.org/Tools/respec/respec-w3c-common' async=""
    class='remove'>
</script>
    <script class='remove'>
      var respecConfig = {
              specStatus:          "ED"
          ,   shortName:           "device-capabilities-api"
          ,   publishDate:         ""
          ,   previousPublishDate: ""
          ,   previousMaturity:    ""
          ,   editors:  [
                  { name: "Hongbo Min", company: "Intel",
                    companyURL: "http://www.intel.com/software" },
                  { name: "Dzung Tran", company: "Intel",
                    companyURL: "http://www.intel.com/software" }
              ]
          ,   edDraftURI:          "http://www.w3.org/2012/sysapps/device-capabilities-api"
          ,   crEnd:               ""
          ,   inlineCSS:           true
          ,   wg:                  "System Application Working Group"
          ,   wgURI:               "http://www.w3.org/2012/sysapps"
          ,   wgPublicList:        "public-sysapps"
          ,   wgPatentURI:         "http://www.w3.org/2004/01/pp-impl/43696/status"
          ,   otherLinks: [
                {
                  key: "Repository",
                  data: [
                     { value: "https://github.com/sysapps/device-capabilities",
                       href: "https://github.com/sysapps/device-capabilities" },
                  ]
                }
             ],
        };
    </script>
  </head>
  <body>
    <section id='abstract'>
      This specification defines a set of System Level APIs to allow Web
      applications retrieve information from the underlying system.
    </section>
    <section id='sotd'>
      <p>
        This document is intended to define the Device Capabilities API to
        retrieve the status of hardware device, get the value of selected
        properties, and subscribe to asynchronous notifications of some
        specific properties in Web applications. To avoid pushing an
        over-complicated and overlapped API definitions, it firstly focuses on
        some general device capabilities, like CPU, memory, storage and display
        and so on. This specification is easy to be extended for supporting a
        new device capability during API evolution.
      </p>
      <p>
        Note that this specification doesn't attempt to re-define device APIs
        which are already officially published by W3C working group, for
        example, <a href="http://www.w3.org/TR/battery-status/">Battery Status
        API</a> , <a href="http://www.w3.org/TR/netinfo-api/">Network
        Information API</a> , and <a href=
        "http://www.w3.org/TR/screen-orientation/">Screen Orientation API</a>.
      </p>
    </section>
    <section class="informative">
      <h2>
        Introduction
      </h2>
      <p>
        The Device Capabilities API provides web apps a way to retrieve device
        and system information from the underlying operating system. Device
        capabilities vary a great deal across the wide range of devices
        applications run on. This API lets applications take advantage of the
        capabilities of the device the application is running on. For example,
        knowing the number of CPU cores allows Web applications to determine an
        appropriate number of Web Workers to create for a worker pool for a
        compute intensive task.
      </p>
    </section>
    <section id="conformance"></section>
    <section>
      <h2>
        Security and Privacy Considerations
      </h2>
      <p>
        A Web application using this API is granted to access some device
        specific data which may contain information that is treated as private
        by end-user. For instance a user may become sensitive to a Web
        application retrieve the available storage free space. Therefore, a
        conforming implementation of this specification MUST provide a
        mechanism that protects the user's privacy and this mechanism should
        ensure that no information exposed by this API is retrievable without
        the permission granted.
      </p>
    </section>
    <section>
      <h2>
        <a>DeviceCapabilities</a> Interface
      </h2>
      <section>
        <p>
          The <a>DeviceCapabilities</a> interface is exposed on the
          <a>Navigator</a> object.
        </p>
        <dl title="partial interface Navigator" class="idl">
          <dt>
            readonly attribute DeviceCapabilities system
          </dt>
          <dd>
            The object that exposes the device capabilities retrieval
            functionality.
          </dd>
        </dl>
        <section>
          <p>
            <a>DeviceCapabilities</a> interface encapsulates a set of methods
            to retrieve the hardware capabilities and specific device data,
            e.g. CPU, storage and display, and event handler to register
            asynchronous notification when the interested system events are
            triggered.
          </p>
          <p>
            The methods defined in <a>DeviceCapabilities</a> are designed to
            return a <dfn id="promise"><code><a href=
            "http://dom.spec.whatwg.org/#promise">Promise</a></code></dfn>
            object and follow a specific pattern when invoked:
          </p>
          <ol>
            <li>Make a request to the system to retrieve the specified
            information implied by the method name;
            </li>
            <li>Let <em><a href="#promise">promise</a></em> be a new
            <code><a href="#promise">Promise</a></code> object and
            <em>resolver</em> its associated resolver.
            </li>
            <li>Return <em><a href="#promise">promise</a></em> and run the
            remaining steps asynchronously.
            </li>
            <li>If an error occurs, run these substeps and then terminate these
            steps:
              <ol>
                <li>Let <em>error</em> be a new <code>DOMError</code> object
                whose name is <code>"UnknownError"</code>,
                </li>
                <li>Run <em>resolver</em>'s internal <em>reject</em> algorithm
                with <em>error</em> as <code>value</code>.
                </li>
              </ol>
            </li>
            <li>If the operation successfully completes, run these substeps:
              <ol>
                <li>Let <em>data</em> be a new object for the specified device
                information (e.g. <a>SystemCPU</a>, <a>SystemStorage</a> and
                <a>SystemDisplay</a>) that were retrieved,
                </li>
                <li>Run <em>resolver</em>'s intenal <code>fulfill</code>
                algorithm with <em>data</em> as <code>value</code>.
                </li>
              </ol>
            </li>
          </ol>
          <dl title="interface DeviceCapabilities : EventTarget" class='idl'>
            <dt>
              Promise getCPUInfo()
            </dt>
            <dd>
              Retrieve the specific information for CPU
            </dd>
            <dt>
              Promise getMemoryInfo()
            </dt>
            <dd>
              Retrieve the memory information
            </dd>
            <dt>
              Promise getStorageInfo()
            </dt>
            <dd>
              Retrieve the storage information
            </dd>
            <dt>
              Promise getDisplayInfo()
            </dt>
            <dd>
              Retrieve the display information
            </dd>
            <dt>
              Promise getAVCodecs()
            </dt>
            <dd>
              Retrieve the audio and video codec information
            </dd>
            <dt>
              attribute <a>EventHandler</a> onstorageattach
            </dt>
            <dd>
              Fired when a new storage is attached to the system. The parameter
              passed to the event handler is the <a>StorageUnit</a> object being
              attached to the system.
            </dd>
            <dt>
              attribute <a>EventHandler</a> onstoragedetach
            </dt>
            <dd>
              Fired when a new storage is detached to the system. The parameter
              passed to the event handler is the <a>StorageUnit</a> object being
              detached to the system.
            </dd>
            <dt>
              attribute <a>EventHandler</a> ondisplayconnect
            </dt>
            <dd>
              Fired when a new display is connected to the system. The
              parameter passed to the event handler is a <a>DisplayUnit</a>
              object being connected to the system.
            </dd>
            <dt>
              attribute <a>EventHandler</a> ondisplaydisconnect
            </dt>
            <dd>
              Fired when a display is removed from the system. The parameter
              passed to the event handler is a <a>DisplayUnit</a> object
              being disconnected to the system.
            </dd>
          </dl>
        </section>
      </section>
    </section>
    <section>
      <h2>
        Device Capabilities Properties
      </h2>
      <section>
        <h2>
          CPU
        </h2>
        <section class='issue'>
          Events will probably work better for properties that change their
          values frequently (e.g. <code>load</code> and
          <code>availCapacity</code>).
        </section>
        <section>
          <p>
            An example for monitoring the CPU load at 1 second interval
            regularly as below:
            <pre class="example highlight">
function watchCPU() {
  navigator.system.getCPUInfo().then(
      function(info) { console.log("CPU load: " + info.load); },
      function(error) { console.log("error occurred: " + error.message); });
}
setTimeout(watchCPU, 1);
            </pre>
          <dl title="interface SystemCPU" class='idl'>
            <dt>
              readonly attribute unsigned int numOfProcessors
            </dt>
            <dd>
              The number of logical processors.
            </dd>
            <dt>
              readonly attribute DOMString archName
            </dt>
            <dd>
              The CPU architecture name, e.g. "x86", "x86_64", "armv6", "armv8"
            </dd>
            <dt>
              readonly attribute float load
            </dt>
            <dd>
              This attribute indicates the current CPU load, as a number between
              0.0 and 1.0.
            </dd>
          </dl>
        </section>
      </section>
      <section>
        <h2>
          Memory
        </h2>
        <section>
          <p>
            An example for monitoring the free memory change at 5 seconds
            interval regularly as below:
          </p>
          <pre class="example highlight">
function monitorFreeMemory() {
  navigator.system.getMemoryInfo().then(
      function(info) { console.log("available bytes: " + info.availCapacity); },
      function(error) { console.log("error occurred: " + error.message); });
}
setTimeout(monitorFreeMemory, 5);
          </pre>
          <dl title="interface SystemMemory" class='idl'>
            <dt>
              readonly attribute unsigned long capacity
            </dt>
            <dd>
              The total capacity of system memory, in bytes.
            </dd>
            <dt>
              readonly attribute unsigend long availCapacity
            </dt>
            <dd>
              The current available capacity of system memory, in bytes.
            </dd>
          </dl>
        </section>
      </section>
      <section>
        <h2>
          Storage
        </h2>
        <section>
          <dl title="interface SystemStorage" class='idl'>
            <dt>
              readonly attribute <a>StorageUnit[]</a> storages
            </dt>
            <dd>
              An array of <a>StorageUnit</a> objects.
            </dd>
          </dl>
          <h2><a>StorageUnit</a> interface</h2>
          <section>
            <dl title="interface StorageUnit" class='idl'>
              <dt>
                attribute readonly DOMString id
              </dt>
              <dd>
                The unique identifier of the storage device
              </dd>
              <dt>
                attribute readonly DOMString name
              </dt>
              <dd>
                The human-readable name for this storage unit.
              </dd>
              <dt>
                attribute readonly DOMString type
              </dt>
              <dd>
                The type of storage device, should be one of <b>'fixed',
                'removable', 'unknown'.</b>
                <ol>
                  <li>
                    If a storage device is an fixed media, e.g. internal SD
                    card, SSD or internal harddisk, it is of <b>'fixed'</b> type. 
                  </li>
                  <li>
                    If a storage device is a plugin-and-play device, e.g. USB
                    flash drive, removable harddisk/SD card, it is of <b>'removable'</b>
                    type.
                  </li>
                  <li>
                    Otherwise, the storage is of <b>'unknown'</b> type.
                  </li>
                </ol>
              </dd>
              <dt>
                attribute readonly unsigned long capacity
              </dt>
              <dd>
                The total capacity of the storage unit, in bytes
              </dd>
            </dl>
          </section>
        </section>
      </section>
      <section>
        <h2>
          Display
        </h2>
        <section>
        <dl title="interface SystemDisplay : EventTarget" class='idl'>
          <dt>
            readonly attribute <a>DisplayUnit[]</a> displays
          </dt>
          <dd>
            An array of <a>DisplayUnit</a> objects
          </dd>
        </dl>
        </section>
        <h2>
          <a>DisplayUnit</a> interface
        </h2>
        <section>
        <dl title="interface DisplayUnit" class='idl'>
          <dt>
            attribute readonly DOMString id
          </dt>
          <dd>
            The unique identifier of the display.
          </dd>
          <dt>
            attribute readonly DOMString name
          </dt>
          <dd>
            The user-friendly name (e.g. "HP LCD monitor").
          </dd>
          <dt>
            attribute readonly boolean isPrimary
          </dt>
          <dd>
            True if this is the primary display.
          </dd>
          <dt>
            attribute readonly boolean isInternal
          </dt>
          <dd>
            True if this is an internal display.
          </dd>
          <dt>
            attribute readonly unsigned int dpiX
          </dt>
          <dd>
            The number of pixels per inch along the x-axis
          </dd>
          <dt>
            attribute readonly unsigned int dpiY
          </dt>
          <dd>
            The number of pixels per inch along the y-axis
          </dd>
          <dt>
            attribute readonly unsigned long width
          </dt>
          <dd>
            The total number of addressable pixels along the x-axis.
          </dd>
          <dt>
            attribute readonly unsigned long height
          </dt>
          <dd>
            The total number of addressable pixels along the y-axis.
          </dd>
          <dt>
            attribute readonly unsigned long availWidth
          </dt>
          <dd>
            The adjusted width to exclude the window decoration if have, 
            e.g. status bar or task bar, if have, in pixels
          </dd>
          <dt>
            attribute readonly unsigned long availHeight
          </dt>
          <dd>
            The adjusted height to exclude the window decoration if have,
            in pixels
          </dd>
        </dl>
      </section>
      </section>
      <section>
        <h2> Audio and Video Codecs </h2>
        <section class="issue">
        Exposing codecs information on client device will improve browser's
        fingerprinting. A better approach might extend to video element to
        add a candidate source and let User Agent to choose the most
        appropriate media content to play back.
        </section>
        <p> Exposes information about the audio/video codecs available on the device </p>
        <section>
          <dl title="interface SystemAVCodecs" class="idl">
            <dt>readonly attribute AudioCodec[] audioCodecs</dt>
            <dd>All available audio codecs supported by the device </dd>
            <dt>readonly attribute VideoCodec[] videoCodecs</dt>
            <dd>All available video codecs supported by the device</dd>
          </dl>
        </section>
        <h3><a>AudioCodec</a> Interface </h3>
        <section>
          <dl title="interface AudioCodec" class="idl">
            <dt>readonly attribute DOMString format</dt>
            <dd>The audio encoding format, e.g. "MP3", "G.711", "MIDI", "MP4"</dd>
          </dl>
        </section>
        <h3><a>VideoCodec</a> Interface </h3>
        <section>
          <dl title="interface VideoCodec" class="idl">
            <dt>readonly attribute DOMString format</dt>
            <dd>The video encoding format, e.g. "H.264", "MPEG4" </dd>
            <dt>readonly attribute boolean hwAccel</dt>
            <dd>True if the video decoding is hardward accelerated, false otherwise</dd>
            <dt>readonly attribute boolean encode</dt>
            <dd>True if the device can encode the video in this format, false otherwise</dd>
          </dl>
        </section>
      </section>
    </section>
    <section>
      <h2>
        Requirements &amp; Use Case
      </h2>
      <b>Stream Video Content to Device</b>
      <p>51% of the online video content in US is user generated.It typically
         is uploaded to a web site like YouTube or Facebook in some user
         generated format. This content can be accessed from different client
         devices which may have media players that supports different set of
         codecs. This implies some level of transcoding that needs to be done
         for the user to be able to vide the media stream. Depending on the
         client device capabilities and network capacity, the cloud app can
         decide what format to transmit to the client:
      </p>
         <ol>
          <li>It can stream the encoded stream if the client device has
              computation or hardware acceleration for decoding.</li>
          <li>It can stream an encoded stream in a format not supported by the
              media player on the client, but the client has the computation or
              hardware acceleration capability for transcoding.</li>
          <li>It can decide to transcode on the server if the client lacks
              either of above capabilities.</li>
          <li>It can decide to decode the video stream and deliver a bit stream
              for a very low-end device.</li>
         </ol>
      <b>Encoding video on the device : local vs cloud</b>
      <p>
        The user wants to share a large family video to others via cloud service
        provider. Before uploading video, an application may need to intelligently
        split up the work of encoding video between the local device, based on its
        capabilities, and a web service in the cloud that encodes video. The
        video codecs information could help application decide to encode the
        large video to a small one if the device has the video encoding capability
        as desired.
      </p>
    </section>
    <section>
      <h2>Acknowledgements</h2>
      <p>Thanks to Anssi Kostiainen for input, thorough reviews and feedback to this draft.</p>
    </section>
  </body>
</html>
